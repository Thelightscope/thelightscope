#!/bin/bash
set -e

# Post-installation script for LightScope

LIGHTSCOPE_USER="lightscope"
LIGHTSCOPE_HOME="/opt/lightscope"
VENV_PATH="$LIGHTSCOPE_HOME/venv"
SERVICE_NAME="lightscope"

echo "Setting up LightScope..."

# Create lightscope user if it doesn't exist
if ! id -u lightscope >/dev/null 2>&1; then
    echo "Creating lightscope user..."
    useradd --system --home /opt/lightscope --create-home --shell /bin/false lightscope
else
    echo "lightscope user already exists"
fi

# Set up directory structure and permissions
mkdir -p /opt/lightscope/{bin,venv,logs,config,updates}
chown -R lightscope:lightscope /opt/lightscope

# Create Python virtual environment
echo "Setting up Python virtual environment..."
python3 -m venv /opt/lightscope/venv
chown -R lightscope:lightscope /opt/lightscope/venv

# Activate virtual environment and install dependencies
echo "Installing Python dependencies..."
source /opt/lightscope/venv/bin/activate

# Upgrade pip first
pip install --upgrade pip

# Install standard dependencies
echo "Installing core dependencies..."
pip install dpkt psutil requests cryptography

# Install systemd-python with error handling
echo "Installing systemd-python for watchdog support..."
if pip install systemd-python; then
    echo "âœ… systemd-python installed successfully"
else
    echo "âš ï¸  Warning: systemd-python installation failed. Watchdog notifications will be disabled."
    echo "   This is not critical - LightScope will still function normally."
fi

# Install local python-libpcap (required for pylibpcap.base import)
PYTHON_LIBPCAP_DIR="/opt/lightscope/python-libpcap"
if [ -d "$PYTHON_LIBPCAP_DIR" ]; then
    echo "Installing local python-libpcap..."
    cd "$PYTHON_LIBPCAP_DIR"
    pip install .
    cd /
else
    echo "python-libpcap directory not found, skipping local installation"
fi

deactivate

# Network capabilities are now handled by systemd service configuration
echo "â„¹ï¸  Network capabilities managed by systemd service (AmbientCapabilities)"

# Generate unique database name during installation
echo "Generating unique database name..."
TODAY=$(date +%Y%m%d)
RAND_PART=$(cat /dev/urandom | tr -dc 'a-z' | head -c 47)
DB_NAME="${TODAY}_${RAND_PART}"
echo "âœ… Generated database name: $DB_NAME"

# Copy configuration files and pre-populate with generated database name
if [ ! -f "$LIGHTSCOPE_HOME/config/config.ini" ]; then
    echo "Creating configuration file with database name: $DB_NAME"
    
    # Create config file with proper database name directly
    cat > "$LIGHTSCOPE_HOME/config/config.ini" << EOF
[Settings]
# Database name for storing LightScope data (auto-generated during installation)
database = $DB_NAME

# Randomization key for IP address anonymization (auto-generated if empty)
randomization_key = 

# Enable automatic SSH/Telnet honeypot port forwarding (yes/no)
self_telnet_and_ssh_honeypot_ports_to_forward = no

# Enable automatic updates (yes/no)
autoupdate = yes

# Update check interval in hours (minimum 1 hour)
update_check_interval = 24

# Enable debug logging (yes/no)
debug_logging = no

# Custom interface to monitor (leave empty for auto-detection)
interface = 

# Maximum number of concurrent honeypot ports
max_honeypot_ports = 10

# Honeypot rotation interval in hours
honeypot_rotation_interval = 4 
EOF
    
    chown "$LIGHTSCOPE_USER:$LIGHTSCOPE_USER" "$LIGHTSCOPE_HOME/config/config.ini"
    echo "âœ… Configuration file created with database name: $DB_NAME"
else
    echo "Configuration file already exists, checking database name..."
    # Update existing config file with the generated database name
    # Use a more robust approach with Python to ensure correct parsing
    python3 << EOF
import configparser
import os

config_file = "$LIGHTSCOPE_HOME/config/config.ini"
db_name = "$DB_NAME"

try:
    config = configparser.ConfigParser()
    config.read(config_file)
    
    if not config.has_section('Settings'):
        config.add_section('Settings')
    
    # Set the database name
    config.set('Settings', 'database', db_name)
    
    # Write back to file
    with open(config_file, 'w') as f:
        config.write(f)
    
    print(f"Updated existing config file with database name: {db_name}")
except Exception as e:
    print(f"Error updating config file: {e}")
    # Fallback to sed approach
    os.system(f"sed -i 's/^database = .*/database = {db_name}/' {config_file}")
EOF
fi

# Update systemd service with database name environment variable
echo "Updating systemd service with database name..."
mkdir -p /etc/systemd/system/lightscope.service.d
cat > /etc/systemd/system/lightscope.service.d/database-name.conf << EOF
# LightScope Database Name Override
# This file is automatically generated during installation
[Unit]
Documentation=https://thelightscope.com https://thelightscope.com/tables/$DB_NAME

[Service]
Environment=LIGHTSCOPE_DB_NAME=$DB_NAME
EOF

# Set proper permissions
chmod 755 "$LIGHTSCOPE_HOME/bin/lightscope-runner.py"
chmod 644 "$LIGHTSCOPE_HOME/config/config.ini"
chmod 755 "$LIGHTSCOPE_HOME/updates"
chmod 644 /etc/systemd/system/lightscope.service.d/database-name.conf

# Enable and start the service
echo "Enabling and starting LightScope service..."
systemctl daemon-reload
systemctl enable "$SERVICE_NAME"
systemctl start "$SERVICE_NAME"

echo "LightScope installation completed successfully!"
echo "Service status:"
systemctl status "$SERVICE_NAME" --no-pager -l

echo ""
echo "=============================================="
echo "ðŸ“Š LIGHTSCOPE DASHBOARD ACCESS"
echo "=============================================="
echo "ðŸ·ï¸  Database Name: $DB_NAME"
echo "ðŸŒ Dashboard URL: https://lightscope.isi.edu/tables/$DB_NAME"
echo "ðŸ“‹ Web Interface: https://lightscope.isi.edu/tables"
echo ""
echo "ðŸ’¡ To find your database name later:"
echo "   sudo systemctl status lightscope"
echo "   (Look for LIGHTSCOPE_DB_NAME in the environment)"
echo ""
echo "=============================================="
echo ""
echo "Configuration file: $LIGHTSCOPE_HOME/config/config.ini"
echo "Log files: $LIGHTSCOPE_HOME/logs/"
echo ""
echo "âœ… LightScope service is now running!"
echo "To check status: sudo systemctl status $SERVICE_NAME"
echo "To view logs: sudo journalctl -u $SERVICE_NAME -f"
echo "To restart: sudo systemctl restart $SERVICE_NAME"
echo "To stop: sudo systemctl stop $SERVICE_NAME"

exit 0 